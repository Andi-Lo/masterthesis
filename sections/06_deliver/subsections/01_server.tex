\subsection{Server}
\label{sub:server}
  Der Nodejs Server stellt verschiedene Endpunkte mittels Express als ansprechbare Routen dem Client zur Verfügung. 

  \begin{figure}[htbp]
    \begin{center}
      \includegraphics[width=\textwidth]{server_client.jpg}
      \caption{Server / Client Relation}
      \label{fig:server_client}
    \end{center}
  \end{figure}

  Trifft eine valide Anfrage auf den \texttt{/trips/:from,:to} Endpunkt, so wird ein Ablauf nach Abbildung \ref{fig:server_client} angestoßen.
  Die eintreffenden Anfragen werden vom Server entgegengenommen, validiert, verarbeitet und anschließend die entsprechende Antwort zurück gesendet. Die Validierung prüft die vom Client übergebenen Parameter auf ihre Plausibilität. Schlägt diese Prüfung fehl wird ein Fehler vom Server zurückgegeben und der Server wartet auf eine neue Anfrage. Die wichtigste Routine des Servers stellt die Abfrage von Trips aus der Datenbank dar. Die Datenbank sucht diejenigen Trips heraus, welche in dem benötigten Zeitraum \texttt{from, to} aktiv sind. Dabei wird das Datum und der Wochentag zum Zeitpunkt der Anfrage verwendet. Damit der Client bei der Animation möglichst wenig Rechenarbeit hat, werden alle Daten, bei denen dies möglichst ist, vorberechnet. Folgender Ablauf findet statt:

  \begin{itemize}
    \item \textbf{Daten Mapping:} Die Trips aus der Datenbank werden in das \texttt{GeoJSON}-Format umgewandelt, damit diese im weiteren Programmverlauf einfacher zu verarbeiten sind. Dabei werden die im Kapitel "`\ref{sub:begriffe} \nameref{sub:begriffe}"' festgelegten Regeln beachtet.

    \item \textbf{Zurückgelegte Distanz:} Damit eine Animation der Vehicle stattfinden kann ist die Berechnung der Distanzen zwischen den einzelnen Stationen nötig. Falls das Feld \texttt{dist\_traveled}\footnotemark in der Datenbank vorhanden ist, kann die zurückgelegte Distanz sehr einfach daraus berechnet werden. Ist dies nicht der Fall so wird ein Station Matching durchgeführt, um die Distanzen berechnen zu können.
    \footnotetext{Die zurückgelegte Distanz bis zu einer Station $S$}

    \item \textbf{Station Matching:} Unter Station Matching versteht sich die Positionierung der Stationen auf und entlang der Polyline. Dies wird im nächsten Abschnitt ausführlicher betrachtet.

    \item \textbf{Feststellen der Richtung:} Für eine Polyline ist es unerheblich ob die Koordinaten in der Reihenfolge $\{ p_1, p_2, \dotsc, p_n \}$ oder $\{ p_n, \dotsc, p_2, p_1 \}$ angeordnet sind. Damit das Vehicle aber in die richtige Richtung von $A$ nach $B$ fährt, ist es wichtig dass die Koordinaten der Polyline in aufsteigender Reihenfolge festgelegt werden. Falls dies nicht er Fall ist, werden die Koordinaten in ihrer Reihenfolge umgekehrt.

    \item \textbf{Codieren der Polyline:} Zuletzt werden die Koordinaten in einen Polyline String Codiert und abschließend versendet.
  \end{itemize}

  \subsubsection{API Endpunkte}
  \label{ssub:api_endpunkte}
    Um einen Datenaustausch zwischen Server und Client zu ermöglichen, sind folgende API\footnotemark Endpunkte vorhanden. 

    \footnotetext{Application Programming Interface}

    \begin{itemize}[label={}]
      \item \textbf{/daily} Stellt die Daten für das Zeitstrahldiagramm bereit. Wird beim Start der Anwendung einmalig Angefragt. Die Antwort enthält XY-Wertpaare. X stellt dabei die Zeit in Sekunden und Y die zu diesem Zeitwert aktiv werdenden Trips dar.

  \begin{lstlisting}[captionpos=t, caption=Antwort des Servers zur Anfrage \texttt{/daily}, label=lst:daily_response]
  [
    {"x":86340,"y":"6"},
    {"x":86400,"y":"10"}, 
    ...
  ]
  \end{lstlisting}

      \item \textbf{/trips/:from,:to} Ermöglicht das Abfragen von Trips, die in einer Zeitspanne \texttt{from - to} aktiv sind. Beim initialen Aufruf der Webanwendung wird dieser Endpunkt als erstes angefragt um die aktiven Trips innerhalb einer Stunde zu bekommen. Der gewählte Zeitraum ist in Sekunden anzugeben. Die Definition ist wie folgt: $t_{from} = now$ und $t_{to} = now + 600 sec$. Die Sekunden lassen sich nach der Formel aus Kapitel \ref{ssub:time} berechnen.
       durch das Addieren der Stunden, Minuten und Sekunden errechnen. Bsp: 17:04:59 Uhr

      $\Rightarrow t_{from} = 61499 \Rightarrow t_{to} = 61499 + 600\;sec$ $\Rightarrow$ \texttt{/trips/61499,62099}

      Die Antwort des Servers auf einen Endpunkt vom Typ \texttt{/trips/} ist ein Objekt mit der Trip\_Id, dessen Inhalt der \texttt{GeoJSON} spezifikation nach RFC 7946 folgt:

  \begin{lstlisting}[captionpos=t, caption=Trip Objekt, label=lst:trip_object]
  {
    2498: {  
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "properties": {
            "name": "shape",
            ...
          },
          "geometry": {
            "type": "LineString",
            "coordinates": [[9.4437,48.64482], ...]
          }
        },
        {
          "type": "Feature",
          "properties": {
            "name": "station"
          },
          "geometry": {
            "type": "Point",
            "coordinates": [9.443688, 48.6448]
          }
        },
        ...
      ]
    }
  }
  \end{lstlisting}
    
      Da die Antwort in Listing \ref{lst:trip_object} mittels "`..."' gekürzt ist, sind detailiertere Antworten im \nameref{sec:anhang} unter Listing \ref{lst:geojson_featurecollection}, \ref{lst:shape_feature} und \ref{lst:station_feature} zu finden.
    

      \item \textbf{/trips/:id} Antwortet mit den zur ID gehörenden Trip Informationen. Dieser Endpunkt ermöglicht es, Informationen für nur einen einzigen Trip zu bekommen. Dies ist vor allem dann hilfreich, wenn der Nutzer ein Vehilce anklickt und Informationen über diesen Trip angezeigt bekommen möchte. Beispiel: \texttt{/trips/51295}

      \item \textbf{/trips/new/:from,:to,:tripIds} Stellt die Abfrage für neue Trips zur Verfügung und exkludiert dabei diejenigen Trips, die in \texttt{:tripIds} genannt sind. Damit wird verhindert, dass bereits auf der Karte vorhandene Trips nicht doppelt auftauchen können. Dieser Query wird in einem 30 Sekunden Intervall vom Client an den Server gesendet um die neusten Trips zu erhalten. Damit wird die Karte aktuell gehalten. Beispiel: Es ist 10:00 Uhr, hole die in der nächsten Minute aktiv werdenden Trips (Zeitraum 10:00 bis 10:01 Uhr) und schließe die Trips mit der ID \texttt{51295,9212,52} vom Ergebnis aus \texttt{/trips/new/36000,36060,51295,9212,52}.

      \item \textbf{/trips/new/:from,:to} Stellt die gleiche Funktionalität wie der vorherige Endpunkt zur Verfügung, mit der Ausnahme, dass keine Trip-ID's übermittelt werden müssen. Dieser Endpunkt ist beispielsweise dafür da, falls die Karte leer ist und noch keine aktiven Trips enthält.

    \end{itemize}

  % subsubsection api_endpunkte (end)

  \subsubsection{Backend Performance}
  \label{ssub:backend_performance}
    In diesem Abschnitt soll das gesamte Backend (Server und Datenbank) evaluiert werden. Dazu werden sowohl die Zeit zum Abfragen der Datenbank, als auch die Zeit zur Datenverarbeitung auf dem Server betrachtet werden.

    \begin{longtable}{|>{\raggedright \arraybackslash}p{4.5cm}|>{\raggedright \arraybackslash}p{1.2cm}|>{\raggedright \arraybackslash}p{1.2cm}|>{\raggedright \arraybackslash}p{1.2cm}|>{\raggedright \arraybackslash}p{1.2cm}|>{\raggedright \arraybackslash}p{1.2cm}|>{\raggedright \arraybackslash}p{1.2cm}|}
    \caption{Backend Evaluation}\label{tbl:backend_evaluation}\\
      \hline
      Anz. Trips & 20 & 100 & 500 & 1000 & 5000 & 10000\\
      \hline
      Query Zeit (ms)        & 25 & 88 & 124 & 200 & 855 & 1631 \\
      Verarbeitungszeit (ms) & 2 & 27 & 40 & 142 & 226 & 435 \\
      Summe (ms)             & 27 & 115 & 164 & 342 & 1081 & 2066 \\
      \hline
    \end{longtable}

    In Tabelle \ref{tbl:backend_evaluation} sind die Datenwerte für verschiedene Abfragen aufgelistet. Die Werte ergeben sich aus dem Mittelwert der Laufzeit in 10 Durchläufen. Wie bereits in Kapitel "`\nameref{ssub:bewältigung_der_datenmenge}"' festgestellt:

    \begin{quote}
      \textit{"`In einer Minute [werden] minimal 0 und maximal 27 Vehicle aktiv. Im Schnitt starten 9 Vehicles pro Minute ihre Fahrt."'}\ref{ssub:bewältigung_der_datenmenge}
    \end{quote}

    Aus dieser Aussage plus den gemessenen Werten lässt sich folgende Schlussfolgerung ziehen: Bei einer Anzahl zwischen 20 und 100 Trips reagiert der Server innerhalb von 25 bis $120ms$. Da die meisten Trips in diese Spanne fallen, ist dieses Ergebnis am bedeutendsten. 

    Im Bereich von 100 bis 500 Trips ist eine Antwortzeit von 115 bis $164ms$ immer noch sehr gut. Diese Anzahl an Trips ist dann relevant, wenn die Applikation das erste mal aufgerufen wird und die Karte noch leer ist. In diesem Fall kann es sein, dass der Server (je nach Datum und Uhrzeit) zwischen 200 - 500 Trips verarbeiten muss. Aber selbst Abfragen von bis zu 10.000 Trips, was ungefähr einer Zeitspanne von einem Tag gleich kommt, sind immer noch innerhalb von 2 Sekunden verarbeitet.\\

    Abschließend kann gesagt werden, dass in dieser Arbeit ein performantes Backendsystem für eine Web Applikation entwickelt worden ist, welches Serveranfragen effizient be- und verarbeiten kann.

  % subsubsection backend_performance (end)
    
% subsection server (end)