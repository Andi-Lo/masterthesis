\subsubsection{Client}
\label{ssub:client}
  Im Client findet die Visualisierung statt. Er stellt die erste Anfrage an den Server um alle Trips in einem Zeitraum zu bekommen. Die Antwort vom Server ist ein Objekt bestehend aus einer ID und einer \texttt{GeoJSON-FeatureCollection}. Die Verwendung von GeoJSON hat den Vorteil, dass verschiedene Bibliotheken für dieses Format zur Verfügung stehen, die dessen Verarbeitung vereinfacht. Auch Mapbox setzt auf die Verwendung von GeoJSON und ist fest damit verbunden. Der Nachteil von GeoJSON ist seine sehr wortreiche Beschreibung. Dass macht es zwar für Menschen gut lesbar, allerdings auf kosten der Datengröße.\\

  Für die Programmierung des Clients werden folgende Bibliotheken als die wichtigsten angesehen:

  \begin{itemize}[label={}]
    \item \textbf{Turf}\footnote{\url{http://turfjs.org/docs/}} Stellt eine ganze Reihe an Funktionen für die raumbezogene Verarbeitung von Daten zur Verfügung. Beispielsweise lassen sich mittels Turf unter anderem Distanzen, Flächen oder Schnittpunkte berechnen.

    \item \textbf{Mapbox-gl-js}\footnote{\url{https://www.mapbox.com/mapbox-gl-js/api/}} wird benötigt um das Kartenmaterial von Mapbox zu verwenden und bietet eine API dafür an.

    \item \textbf{Lodash}\footnote{\url{https://lodash.com/}} ist eine Hilfsbibliothek, die verschiedene Funktionen zur Verfügung stellt, die das Arbeiten mit JavaScript vereinfachen.

    % \item \textbf{Moment}\footnote{\url{http://momentjs.com/}} bietet das Validieren, Parsen, Manipulieren und Anzeigen von Zeitinformationen. Vor allem das Umwandeln von verschiedenen Zeitformaten erwies sich als hilfreich. 
    % maybe change to timeFormatter  https://www.npmjs.com/package/time-formater
  \end{itemize}

  % Todo: Eventuell doch auslagern in neue Datei + subsubsection?
  % Eventuell vehicle object und architektur ein wenig beschreiben? Vielleicht UML Diagramm? (mb zu aufwendig)


  \subsubsection*{Algorithmen}
  \label{ssub:algorithmen}
    Der wichtigste Algorithmen des Clients ist \texttt{AnimateVehicle}. Dieser solle in diesem Abschnitt in der Form von Pseudo-Code erläutert werden.\\

    Nachdem die angefragten Trips beim Client eingetroffen sind, wird ein Animation-Loop begonnen, der die Vehicle auf der Karte animiert. Dazu wird ein Algorithmus, der in Listing \ref{alg:animate_algorithmus} beschrieben wird, verwendet.

    \pagebreak
    \begin{algorithm}[H]
      \caption{Animate Vehicle}\label{alg:animate_algorithmus}
      \begin{algorithmic}[1]
        \Procedure{animateVehicle}{}
          \State ServerQueryTimer $\gets$ 30 Seconds
          \State Vehicles $\gets$ Vehicles Inside Bounding Box
          \State Trips $\gets$ Requested Trips
          \Function{animate}{timestamp}
            \ForAll{Vehicles as Vehicle} \State{
              \If{Vehicle started its Trip} 
                \State \Call{calculateVehiclePosition}{Vehicle}
              \EndIf
              \If{Vehicle not started its Trip}
                \State \Call{checkVehicleActivity}{Vehicle, Trips}
              \EndIf
              \State \Call{checkIfVehicleHasFinished}{Vehicle}
              \State \Call{updateMapWithNewPositions}{Vehicles}
            }\EndFor

            \If{ServerQueryTimer Expired} 
              \State Query Server for New Trips
              \State ServerQueryTimer $\gets$ 30 Seconds
            \EndIf

            \State \Call {animate}{timestamp}
          \EndFunction
          
        \EndProcedure
      \end{algorithmic}
    \end{algorithm}
   % subsubsection algorithmen (end)

   Innerhalb dieses Animation-Loops passieren mehrere Dinge. Zuerst wird geprüft ob sich ein Vehicle überhaupt im Sichtbereich des Anwenders befindet. Trifft das zu, wird für eben diese Vehicle die Distanzen berechnet und die Position des Vehicles entlang der Polyline interpoliert. Falls das Vehicle seinen Trip noch nicht begonnen hat, wird überprüft ob das immer noch der Fall ist. Anschließend werden alle Vehicle geprüft, ob sie ihren Trip erledigt haben. Danach werden die Karte mit den neuen Positionen der Vehicle aktualisiert. Während all dies geschieht, läuft ein Timer mit, der nach dem Ablaufen von 30 Sekunden den Server nach neuen Trips befragt.

% subsubsection client (end)